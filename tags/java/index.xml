<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Coding Automaton</title>
    <link>http://jessezhuang.github.io/tags/java/</link>
    <description>Recent content in Java on Coding Automaton</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 Jun 2016 14:55:57 -0700</lastBuildDate>
    <atom:link href="http://jessezhuang.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MongoDB Tutorial 5 - Aggregation Framework</title>
      <link>http://jessezhuang.github.io/article/mongodb-aggregation-framework/</link>
      <pubDate>Sun, 26 Jun 2016 14:55:57 -0700</pubDate>
      
      <guid>http://jessezhuang.github.io/article/mongodb-aggregation-framework/</guid>
      <description>

&lt;p&gt;The aggregation framework has its roots in SQL&amp;rsquo;s world of &lt;code&gt;groupby&lt;/code&gt; clause.&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Example used: imagine a SQL table of products.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;category&lt;/th&gt;
&lt;th&gt;manufacture&lt;/th&gt;
&lt;th&gt;price&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ipad&lt;/td&gt;
&lt;td&gt;tablet&lt;/td&gt;
&lt;td&gt;Apple&lt;/td&gt;
&lt;td&gt;499&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nexus s&lt;/td&gt;
&lt;td&gt;cellphone&lt;/td&gt;
&lt;td&gt;Samsung&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To get number of products from each manufacture with SQL,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select manufacture, count(*) from products
  group by manufacture;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with mongodb,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; use agg
&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:&amp;quot;$manufacturer&amp;quot;, // creating new collection
      num_products:{$sum:1}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : &amp;quot;Amazon&amp;quot;, &amp;quot;num_products&amp;quot; : 2}
{&amp;quot;_id&amp;quot; : &amp;quot;Sony&amp;quot;, &amp;quot;num_products&amp;quot; : 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do compound grouping with SQL,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select manufacturer, category, count(*) from
  products group by manufacturer, category
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with mongodb,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([
  {$group:
    {
      // _id can be a complex document, just have to be unique
      _id:{&amp;quot;manufacturer&amp;quot;:&amp;quot;$manufacturer&amp;quot;,&amp;quot;category&amp;quot;:&amp;quot;category&amp;quot;},
      num_products:{$sum:1}
    }
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;manufacturer&amp;quot;:&amp;quot;Amazon&amp;quot;, &amp;quot;category&amp;quot;:&amp;quot;Tablets&amp;quot;}, &amp;quot;num_products&amp;quot; : 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/sql-aggregation-comparison/&#34;&gt;SQL to Aggregation Mapping Chart&lt;/a&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;
.&lt;/p&gt;

&lt;p&gt;One can group on &lt;code&gt;_id:null&lt;/code&gt; to aggregate every single document such as counting or summing.&lt;/p&gt;

&lt;h1 id=&#34;aggregation-pipeline&#34;&gt;Aggregation Pipeline&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://jessezhuang.github.io/img/mongodb-aggregation-pipeline.png&#34; alt=&#34;mongodb-aggregation-pipeline&#34; /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;pipeline stages&lt;/th&gt;
&lt;th&gt;job&lt;/th&gt;
&lt;th&gt;documents handling&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$project&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;reshape documents, select out fields potentially deep in hierarchy&lt;/td&gt;
&lt;td&gt;1:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$match&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;filter out&lt;/td&gt;
&lt;td&gt;n:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$group&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;n:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$sort&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;sorting&lt;/td&gt;
&lt;td&gt;1:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$skip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;skips&lt;/td&gt;
&lt;td&gt;n:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$limit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;limit&lt;/td&gt;
&lt;td&gt;n:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$unwind&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;normalize, flatten data before grouping&lt;/td&gt;
&lt;td&gt;1:n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$out&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;redirect output&lt;/td&gt;
&lt;td&gt;1:1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$redact&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;security related&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$geonear&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;location based searching&lt;/td&gt;
&lt;td&gt;n:1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;$unwind&lt;/code&gt; example: &lt;code&gt;tags:[red, blue]&lt;/code&gt; unwinds to &lt;code&gt;tag:red&lt;/code&gt; and &lt;code&gt;tag:blue&lt;/code&gt;, expanding the number of documents.&lt;/p&gt;

&lt;h2 id=&#34;more-operators-with-examples-i-class-fa-fa-arrow-up-aria-hidden-true-i&#34;&gt;More Operators with Examples &lt;a href=&#34;#&#34;&gt;&lt;i class=&#34;fa fa-arrow-up&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;$sum&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:{&amp;quot;maker&amp;quot;:&amp;quot;$manufacturer&amp;quot;}, // creating new collection
      sum_prices:{$sum:&amp;quot;$price&amp;quot;}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;maker&amp;quot;:&amp;quot;Amazon&amp;quot;}, &amp;quot;sum_prices&amp;quot; : 328}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$avg&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:{&amp;quot;category&amp;quot;:&amp;quot;$category&amp;quot;}, // creating new collection
      avg_prices:{$avg:&amp;quot;$price&amp;quot;}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;category&amp;quot;:&amp;quot;Tablets&amp;quot;}, &amp;quot;avg_prices&amp;quot; : 396.42714}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$addToSet&lt;/code&gt; operator without counterpart in SQL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:{&amp;quot;maker&amp;quot;:&amp;quot;$manufacturer&amp;quot;}, // creating new collection
      categories:{$addToSet:&amp;quot;$category&amp;quot;}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;maker&amp;quot;:&amp;quot;Apple&amp;quot;}, &amp;quot;categories&amp;quot; : [&amp;quot;Laptops&amp;quot;, &amp;quot;Tablets&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$push&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:{&amp;quot;maker&amp;quot;:&amp;quot;$manufacturer&amp;quot;}, // creating new collection
      categories:{$push:&amp;quot;$category&amp;quot;}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;maker&amp;quot;:&amp;quot;Apple&amp;quot;}, &amp;quot;categories&amp;quot; :
  [&amp;quot;Tablets&amp;quot;, &amp;quot;Tablets&amp;quot;, &amp;quot;Tablets&amp;quot;, &amp;quot;Laptops&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$max&lt;/code&gt; and &lt;code&gt;$min&lt;/code&gt; operators:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;gt; db.products.aggregate([ // array
  {$group:
    {
      _id:{&amp;quot;maker&amp;quot;:&amp;quot;$manufacturer&amp;quot;}, // creating new collection
      maxprice:{$max:&amp;quot;$price&amp;quot;}
    } // a series of upserts
  }
])
{&amp;quot;_id&amp;quot; : {&amp;quot;maker&amp;quot;:&amp;quot;Apple&amp;quot;}, &amp;quot;maxprice&amp;quot; : 699 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$project&lt;/code&gt; phase/stage: you can remove, add, reshape keys, use simple functions on keys such as &lt;code&gt;$toUpper&lt;/code&gt;, &lt;code&gt;$toLower&lt;/code&gt;, &lt;code&gt;$add&lt;/code&gt;, &lt;code&gt;$multiply&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.products.aggregate([
  {$project:
    {
      _id:0,
      &#39;maker&#39;: {$toLower:&amp;quot;$manufacturer&amp;quot;},
      &#39;details&#39;: {&#39;category&#39;: &amp;quot;$category&amp;quot;,
        &#39;price&#39; : {&amp;quot;$multiply&amp;quot;:[&amp;quot;$price&amp;quot;,10]}
      },
      &#39;item&#39;:&#39;$name&#39;
    }
  }
])
{&amp;quot;maker&amp;quot;:&amp;quot;amazon&amp;quot;, &amp;quot;details&amp;quot;:{&amp;quot;category&amp;quot;:&amp;quot;Tablets&amp;quot;, &amp;quot;price&amp;quot;:1990},
  &amp;quot;item&amp;quot;:&amp;quot;Kindle Fire&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$match&lt;/code&gt; phase. One thing to note about $match (and $sort) is that 
&lt;a target=&#34;_blank&#34; href=&#34;http://docs.mongodb.org/manual/core/aggregation-pipeline/?_ga=1.241498631.463502008.1466893758&#34;&gt;they can use indexes&lt;/a&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;
, but only if done at the beginning of the aggregation pipeline. 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/tutorial/aggregation-zip-code-data-set/&#34;&gt;Example zips collection.&lt;/a&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.zips.aggregate([
  {$match:
    {
      state:&amp;quot;NY&amp;quot;
    }
  },
  {$group:
    {
      _id: &amp;quot;$city&amp;quot;,
      population: {$sum:&amp;quot;$pop&amp;quot;},
      zip_codes: {$addToSet: &amp;quot;$_id&amp;quot;}
    }
  },
  {$project:
    {
      _id: 0,
      city: &amp;quot;$_id&amp;quot;,
      population: 1,
      zip_codes:1
    }
  },
  {$sort:
    {population:-1}
  },
  {$skip:10},
  {$limit:5}
])
{&amp;quot;population&amp;quot;:9743, &amp;quot;zip_codes&amp;quot;:[96162, 96161], &amp;quot;city&amp;quot;:&amp;quot;TRUCKEE&amp;quot;}
// order of fields not retained
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$sort&lt;/code&gt; operator. The aggregation framework supports both memory (default, 100 MB limit for each pipeline stage unless allowing disk) and disk based sorting. Sorting can be done before or after the grouping stage.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$skip&lt;/code&gt; and &lt;code&gt;$limit&lt;/code&gt; works similarly in &lt;code&gt;find()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$unwind&lt;/code&gt; operator: it&amp;rsquo;s not easy to group on the array elements (prejoined data) so we need to flatten (unjoin, data explosion) the array.&lt;/p&gt;

&lt;p&gt;To count how many posts were attached to each tag in the blog,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;use blog;
db.posts.aggregate([
    /* unwind by tags */
  {&amp;quot;$unwind&amp;quot;:&amp;quot;$tags&amp;quot;},
    /* now group by tags, counting each tag */
  {&amp;quot;$group&amp;quot;:
    {&amp;quot;_id&amp;quot;:&amp;quot;$tags&amp;quot;,
    &amp;quot;count&amp;quot;:{$sum:1}
    }
  },
  /* sort by popularity */
  {&amp;quot;$sort&amp;quot;:{&amp;quot;count&amp;quot;:-1}},
  /* show me the top 10 */
  {&amp;quot;$limit&amp;quot;: 10},
  /* change the name of _id to be tag */
  {&amp;quot;$project&amp;quot;:
    {_id:0,
      &#39;tag&#39;:&#39;$_id&#39;,
      &#39;count&#39; : 1
    }
  }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;To reverse $unwind&lt;/p&gt;
&lt;p&gt;You can use $push to reverse the effects of an $unwind. If the array elements were unique, $addToSet will also do the job.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;more-advanced-aggregation-examples&#34;&gt;More Advanced Aggregation Examples&lt;/h2&gt;

&lt;h3 id=&#34;double-grouping-i-class-fa-fa-arrow-up-aria-hidden-true-i&#34;&gt;Double Grouping &lt;a href=&#34;#&#34;&gt;&lt;i class=&#34;fa fa-arrow-up&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;For a collection of student grades like below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;_id&amp;quot; : { &amp;quot;$oid&amp;quot; : &amp;quot;50b59cd75bed76f46522c34e&amp;quot; },
  &amp;quot;student_id&amp;quot; : 0, &amp;quot;class_id&amp;quot; : 2,
  &amp;quot;scores&amp;quot; : [ { &amp;quot;type&amp;quot; : &amp;quot;exam&amp;quot;, &amp;quot;score&amp;quot; : 57.92947112575566 },
    { &amp;quot;type&amp;quot; : &amp;quot;quiz&amp;quot;, &amp;quot;score&amp;quot; : 21.24542588206755 },
    { &amp;quot;type&amp;quot; : &amp;quot;homework&amp;quot;, &amp;quot;score&amp;quot; : 68.19567810587429 },
    { &amp;quot;type&amp;quot; : &amp;quot;homework&amp;quot;, &amp;quot;score&amp;quot; : 67.95019716560351 },
    { &amp;quot;type&amp;quot; : &amp;quot;homework&amp;quot;, &amp;quot;score&amp;quot; : 18.81037253352722 }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to figure out the average class grade for each class,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.grades.aggregate([
    {&#39;$group&#39;:{_id:{class_id:&amp;quot;$class_id&amp;quot;, student_id:&amp;quot;$student_id&amp;quot;},
      &#39;average&#39;:{&amp;quot;$avg&amp;quot;:&amp;quot;$score&amp;quot;}}
    }, // pipe to a secondary grouping stage
    {&#39;$group&#39;:{_id:&amp;quot;$_id.class_id&amp;quot;, &#39;average&#39;:{&amp;quot;$avg&amp;quot;:&amp;quot;$average&amp;quot;}}}
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$first&lt;/code&gt; and &lt;code&gt;$last&lt;/code&gt;, example: find city with largest population in each state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;b.zips.aggregate([
  /* get the population of every city in every state */
  {$group:
    {
      _id: {state:&amp;quot;$state&amp;quot;, city:&amp;quot;$city&amp;quot;},
      population: {$sum:&amp;quot;$pop&amp;quot;},
    }
  },
  /* sort by state, population */
  {$sort:
    {&amp;quot;_id.state&amp;quot;:1, &amp;quot;population&amp;quot;:-1}
  },
  /* group by state, get the first item in each group */
  {$group:
    {
      _id:&amp;quot;$_id.state&amp;quot;,
      city: {$first: &amp;quot;$_id.city&amp;quot;},
      population: {$first:&amp;quot;$population&amp;quot;}
    }
  },
  /* now sort by state again */
  {$sort:
   {&amp;quot;_id&amp;quot;:1}
  }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$out&lt;/code&gt; redirects the output to a new collection, write over, no appending, considering a games collection with documents structured like,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;{
  &amp;quot;_id&amp;quot;:ObjectId(&amp;quot;53684890&amp;quot;),
  first_name: &amp;quot;Jerzy&amp;quot;,
  last_name: &amp;quot;Fischer&amp;quot;,
  points: 3,
  moves: [1,2,5]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To summarize each person&amp;rsquo;s points,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.games.aggregate([
  {$group:
    {_id:{first_name:&amp;quot;$first_name&amp;quot;, last_name:&amp;quot;$last_name&amp;quot;},
    points:{$sum:&amp;quot;$points&amp;quot;}
    }
  },
  {$out:&amp;quot;summary_results&amp;quot;}
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;_id&lt;/code&gt; field of the redirected output must be unique, the operations below will not succeed and leave the &lt;code&gt;summary_results&lt;/code&gt; collection untouched.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.games.aggregate([
  {$unwind:&amp;quot;moves&amp;quot;},
  {$out:&amp;quot;summary_results&amp;quot;}
])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;double-unwind&#34;&gt;Double &lt;code&gt;$unwind&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Create a Cartesian product of the two or more arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.inventory.aggregate([
  {$unwind: &amp;quot;$sizes&amp;quot;},
  {$unwind: &amp;quot;$colors&amp;quot;},
  {$group:
    {
      &#39;_id&#39;: {&#39;size&#39;:&#39;$sizes&#39;, &#39;color&#39;:&#39;$colors&#39;},
      &#39;count&#39; : {&#39;$sum&#39;:1}
    }
  }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To reverse with &lt;code&gt;$addToSet&lt;/code&gt; in one stage since array elements were unique,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.inventory.aggregate([
  {$unwind: &amp;quot;$sizes&amp;quot;},
  {$unwind: &amp;quot;$colors&amp;quot;},
  {$group:
    {
      &#39;_id&#39;: &amp;quot;$name&amp;quot;,
      &#39;sizes&#39;: {$addToSet: &amp;quot;$sizes&amp;quot;},
      &#39;colors&#39;: {$addToSet: &amp;quot;$colors&amp;quot;},
    }
  }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To reverse with &lt;code&gt;$push&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.inventory.aggregate([
  {$unwind: &amp;quot;$sizes&amp;quot;},
  {$unwind: &amp;quot;$colors&amp;quot;},
  /* create the color array */
  {$group:
    {
      &#39;_id&#39;: {name:&amp;quot;$name&amp;quot;,size:&amp;quot;$sizes&amp;quot;},
      &#39;colors&#39;: {$push: &amp;quot;$colors&amp;quot;},
    }
  },
  /* create the size array */
  {$group:
    {
      &#39;_id&#39;: {&#39;name&#39;:&amp;quot;$_id.name&amp;quot;,
      &#39;colors&#39; : &amp;quot;$colors&amp;quot;},
      &#39;sizes&#39;: {$push: &amp;quot;$_id.size&amp;quot;}
    }
  },
  /* reshape for beauty */
  {$project:
    {
      _id:0,
      &amp;quot;name&amp;quot;:&amp;quot;$_id.name&amp;quot;,
      &amp;quot;sizes&amp;quot;:1,
      &amp;quot;colors&amp;quot;: &amp;quot;$_id.colors&amp;quot;
    }
  }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;full-text-search-and-aggregation-i-class-fa-fa-arrow-up-aria-hidden-true-i&#34;&gt;Full Text Search and Aggregation &lt;a href=&#34;#&#34;&gt;&lt;i class=&#34;fa fa-arrow-up&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Two great taste that go great together.&amp;rdquo; - &lt;a href=&#34;https://twitter.com/erlichson?lang=en&#34;&gt;Andrew Erlichson&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;db.sentences.aggregate([
  {$match:{$text:{$search:&amp;quot;tree rat&amp;quot;}}},// must appear first
  // one full text search per collection, no need to specify
  {$sort:{score:{$meta:&amp;quot;textScore&amp;quot;}}},
  {$project:{words:1, _id:0}}
])
{&amp;quot;words&amp;quot;:&amp;quot;rat shrub granite.&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$text&lt;/code&gt; is only allowed in the $match stage of the aggregation pipeline and must be the first stage of the aggregation pipeline.&lt;/p&gt;

&lt;h3 id=&#34;aggregation-with-java-driver&#34;&gt;Aggregation with Java driver&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ZipCodeAggregationTest {
  public static void main (Strng[] args) {
    MongoClient client = new MongoClient();
    MongoDatabase database = client.getDatabase(&amp;quot;course&amp;quot;);
    MongoCollection&amp;lt;Document&amp;gt; collection = database.getCollection(&amp;quot;zipcodes&amp;quot;);

    // verbose
    // List&amp;lt;Document&amp;gt; pipeline = Arrays.asList(new Document(&amp;quot;$group&amp;quot;,
    //   new Document(&amp;quot;_id&amp;quot;, &amp;quot;$state&amp;quot;).append(&amp;quot;totalPop&amp;quot;, new Document(
    //     &amp;quot;$sum&amp;quot;, &amp;quot;$pop&amp;quot;))), new Document(&amp;quot;$match&amp;quot;, new Document(&amp;quot;totalPop&amp;quot;,
    //       new Document(&amp;quot;$gte&amp;quot;, 10000000))));

    List&amp;lt;Bson&amp;gt; pipeline = Arrays.asList(Aggregates.group(&amp;quot;$state&amp;quot;, Accumulators.sum(&amp;quot;totalPop&amp;quot;,
      &amp;quot;$pop&amp;quot;)), Aggregates.match(gte(&amp;quot;totalPop&amp;quot;, 10000000)));

    List&amp;lt;Document&amp;gt; pipeline2 = Arrays.asList(Document.parse(
      &amp;quot;{ $group: { _id: \&amp;quot;$state\&amp;quot;, totalPop: { $sum: \&amp;quot;$pop\&amp;quot; } } }&amp;quot;),
      Document.parse(&amp;quot;{ $match: { totalPop: { $gte: 1010001000 } } }&amp;quot;));

    List&amp;lt;Document&amp;gt; results = collection.aggregate(pipeline).
      into(new ArrayList&amp;lt;Document&amp;gt;());
    // List&amp;lt;Document&amp;gt; results = collection.find().into(new ArrayList&amp;lt;Document&amp;gt;());

    for (Document cur : results) {
      System.out.println(cur.toJson());
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;aggregation-options&#34;&gt;Aggregation Options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;explain&lt;/code&gt; gets the query plan if we ran it, useful in optimization.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allowDiskUse&lt;/code&gt; allows use of hard drive for intermediate stages. Any stage is limited to 100 MB of memory use and will fail if exceeded. Certain stages like projection run the documents through and don&amp;rsquo;t use a lot of memory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cursor&lt;/code&gt; allows cursor use and specify cursor size.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;use agg
db.zips.aggregate(
  [{$group:{_id:&amp;quot;$state&amp;quot;, population:{$sum:&amp;quot;$pop&amp;quot;}}}],
  {explain:true},
  {allowDiskUse:true}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two forms of aggregation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aggregate([stage1, stage2, ...])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aggregate(stage1, stage2, ...)&lt;/code&gt; cannot add options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Prior to the release of the 3.0 pymongo driver, you would get a document for aggregation queries by default (the aggregation result is limited by the 16 Mb size), though you had the option of getting back a cursor if you were working with MongoDB 2.6.0+, and your pymongo version was 2.6.0+. Starting with the release of the 3.0 pymongo driver, however the aggregation pipeline queries using the driver will now return a cursor by default.&lt;/p&gt;

&lt;p&gt;The mongo shell returns a cursor by default starting 2.6.0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pymongo
connection = pymongo.MongoClient()
db = connection.agg

result = db.zips.aggregate([{&#39;$group&#39;:{&#39;_id&#39;:&#39;state&#39;,
  &#39;population&#39;:{&#39;$sum&#39;:&#39;$pop&#39;}}}])

print result
# &amp;lt;pymongo.command_cursor.CommandCursor object at 0x7f62829f5210&amp;gt; in 3.2.6

# piror to 3.0
result = db.zips.aggregate([{&#39;$group&#39;:{&#39;_id&#39;:&#39;state&#39;,
    &#39;population&#39;:{&#39;$sum&#39;:&#39;$pop&#39;}}}], cursor={}, allowDiskUse=True)

for doc in result:
    print doc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# prior to 3.0
{u&#39;ok&#39;:1.0, u&#39;result&#39; : [array of resulted documents]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;limitations-of-aggregation-framework&#34;&gt;Limitations of Aggregation framework&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;100 MB limit for pipeline stages, &lt;code&gt;allowDiskUse&lt;/code&gt; to get around.&lt;/li&gt;
&lt;li&gt;16 MB limit if you decide to return the result as a single document, set &lt;code&gt;cursor&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In a sharded system, stages like &lt;code&gt;$group&lt;/code&gt;, &lt;code&gt;$sort&lt;/code&gt; will bring back the results to the first shard. Stages like &lt;code&gt;$match&lt;/code&gt; and &lt;code&gt;$project&lt;/code&gt; can go in parallel. Aggregation in mongodb is an interface to map/reduce jobs. Alternatively, get the data out of mongodb using the hadoop connector and use Hadoop map/reduce. There is a map/reduce functionality built into mongodb that is not recommended.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://jessezhuang.github.io/img/mongodb-limitation.png&#34; alt=&#34;mongodb sharded system limitation&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;resources&#34;&gt;Resources&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://university.mongodb.com/courses/M101P/about&#34;&gt;MongoDB University Classes&lt;/a&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/&#34;&gt;MongoDB Docs&lt;/a&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;#&#34;&gt;go to top &lt;i class=&#34;fa fa-arrow-up&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jessezhuang.github.io/
tags/mongodb/&#34;&gt;Link to the MongoDB tutorial series.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Java&#39;s Reflection for Testing</title>
      <link>http://jessezhuang.github.io/article/java-reflection-test/</link>
      <pubDate>Sun, 19 Jun 2016 01:20:46 -0700</pubDate>
      
      <guid>http://jessezhuang.github.io/article/java-reflection-test/</guid>
      <description>

&lt;h2 id=&#34;writing-boilerplate-test-code-is-boring&#34;&gt;Writing Boilerplate Test Code is Boring&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://jessezhuang.github.io/img/java-reflection.png&#34; alt=&#34;Java Reflection&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Repeatedly writing boilerplate for loops for testing is not fun. We can use Java reflection API (&lt;code&gt;java.lang.reflect&lt;/code&gt; package) to maximize code reuse and help testing.&lt;/p&gt;

&lt;p&gt;Frameworks like JUnit uses reflection for testing. I will introduce a single method today on how reflection can be used for testing.&lt;/p&gt;

&lt;p&gt;The code examples below are available at my &lt;a href=&#34;https://github.com/JesseZhuang/SimpleJavaTools&#34;&gt;github repository&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;get-an-instance-of-class-being-tested&#34;&gt;Get an Instance of Class Being Tested&lt;/h2&gt;

&lt;p&gt;First we will declare a message to print out if all tests passed. Unfortunately you don&amp;rsquo;t usually get to see this message till the end of debugging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final static String SUCCESS = &amp;quot;Congrats! All tests passed.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we will make sure the input array and the expected result array have same number of elements with &lt;code&gt;validateLengths&lt;/code&gt; method which is trivial to implement.&lt;/p&gt;

&lt;p&gt;Then we will get a class type &lt;code&gt;Class&amp;lt;?&amp;gt;&lt;/code&gt; from the &lt;code&gt;className&lt;/code&gt; parameter, get the input class type with the first element of the input array &lt;code&gt;inputs[0]&lt;/code&gt;, and get the method being tested with &lt;code&gt;class.getMethod&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, we will instantiate an object for the class for the cases where the tested method is an instance method. If the method is a static method, this object will be ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T, R&amp;gt; void assertEqual(String className,
  String methodName, T[] inputs, R[] expected) {
  // make sure they have same length
  validateLengths(inputs, expected);

  try {
    // use reflection to get type of class indicated by &amp;quot;className&amp;quot;
    Class&amp;lt;?&amp;gt; c = Class.forName(className);
    Class&amp;lt;T&amp;gt; inputType = (Class&amp;lt;T&amp;gt;) inputs[0].getClass();
    Method m = c.getMethod(methodName, inputType);

    // static methods will ignore this instance
    Object o = c.newInstance();
    // code continue in next block for actual testing
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-actual-testings&#34;&gt;The Actual Testings&lt;/h2&gt;

&lt;p&gt;Next we will use for loops to iterate over the array for all test cases. We write these loops here once and then we can call this method from the class being tested.&lt;/p&gt;

&lt;p&gt;For nested array, we have to test for deep equality. The testing will quit on the first failed test and print out the information about the input, output, and expected result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;{ //continue from top
  {
    for (int i = 0; i &amp;lt; inputs.length; i++) {
      R e = expected[i];
      R output = (R) m.invoke(o, inputs[i]);

      // has to test deep equal for array type
      if (e.getClass().isArray()) {
        int n = Array.getLength(e);
        for (int j = 0; j &amp;lt; n; j++) {
          if (!Array.get(e, j).equals(Array.get(output, j))) {
            System.out.println(&amp;quot;test failed for &amp;quot;
              + Arrays.asList(inputs[i]) + &amp;quot; expected &amp;quot;
              + Arrays.asList(e) + &amp;quot;, output &amp;quot;
              + Arrays.asList(output));
            System.exit(-1);
          }
        }
      } else if (!e.equals(output)) {
        System.out.println(&amp;quot;test:\n &amp;quot; + inputs[i] + &amp;quot;failed, &amp;quot;
          + &amp;quot; expected &amp;quot; + expected + &amp;quot;, output &amp;quot; + output);
        System.exit(-1);
      }

    }

    // all tests passed
    System.out.println(SUCCESS);

  } catch (ClassNotFoundException | IllegalAccessException
    | IllegalArgumentException | InvocationTargetException
    | NoSuchMethodException | SecurityException
    | InstantiationException e) {
    //handle your exceptions here
    e.printStackTrace();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoke-the-method-from-the-class-being-tested&#34;&gt;Invoke the Method from the Class Being Tested&lt;/h2&gt;

&lt;p&gt;To use the test method, call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TestClass.assertEqual(&amp;quot;my.pkg.className&amp;quot;,&amp;quot;methodName&amp;quot;,inputArray,
         expectedResultsArray);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;Don&amp;rsquo;t forget to include the package name in the first parameter as the class name. Please note that Class.getMethod() only searches for public methods.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
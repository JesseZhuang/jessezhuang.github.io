<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Coding Automaton</title>
    <link>http://jessezhuang.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on Coding Automaton</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Aug 2016 17:12:46 -0700</lastBuildDate>
    <atom:link href="http://jessezhuang.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Algorithm Question Substring Search KMP</title>
      <link>http://jessezhuang.github.io/article/algorithm-string-KMP/</link>
      <pubDate>Fri, 05 Aug 2016 17:12:46 -0700</pubDate>
      
      <guid>http://jessezhuang.github.io/article/algorithm-string-KMP/</guid>
      <description>

&lt;h1 id=&#34;question&#34;&gt;Question&lt;/h1&gt;

&lt;p&gt;LeetCode has this question Implement strStr().&lt;/p&gt;

&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;

&lt;p&gt;Tags: Two Pointers, String.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s denote haystack length &lt;code&gt;N&lt;/code&gt;, needle length &lt;code&gt;M&lt;/code&gt;, character table size &lt;code&gt;R&lt;/code&gt; (256 for extended ASCII).&lt;/p&gt;

&lt;p&gt;Java&amp;rsquo;s &lt;code&gt;String&lt;/code&gt; class method &lt;code&gt;indexOf()&lt;/code&gt; uses brute force algorithm O(MN).&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;haystacsflksdjflkshhaystackneeneeneedle
         needle
naslkfjskjlhhhh
needle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;method-1-2d-dfa&#34;&gt;Method 1 2D DFA&lt;/h2&gt;

&lt;p&gt;KMP Knuth Morris Pratt O(N) time complexity.&lt;/p&gt;

&lt;p&gt;2D array DFA[256][M] gives the next character index to match against i.&lt;/p&gt;

&lt;p&gt;Example: needle &amp;ldquo;ABABAC&amp;rdquo;. DFA[r][j] where r &amp;lt; R, j &amp;lt; M.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;j    :  0 1 2 3 4 5 6
state:  0 0 1 2 3 0
r       A B A B A C
A       1 1 3 1 5 1 
B       0 2 0 4 0 4
C       0 0 0 0 0 6
D       0 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Steps to build DFA:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;copy mismatched cases (first column all 0).&lt;/li&gt;
&lt;li&gt;set matched character to go to next state (first column DFA[needle.charAt(0)][0] = 1).&lt;/li&gt;
&lt;li&gt;start state 0, update state for j in [1, M-1].&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DFA[needle.charAt(0)][0] = 1;
int state = 0;
for (int j = 1; j &amp;lt; M; j++) {
  for (int r = 0; r &amp;lt; 256; r++) DFA[r][j] = DFA[r][state];
  DFA[needle.charAt(j)][j] = j + 1;    
  state = DFA[needle.charAt(j)][state];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note DFA[\&amp;rsquo;D\&amp;lsquo;][5] = 0 but DFA[&amp;lsquo;B&amp;rsquo;][5] = 4.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++) {
  //no backup, so can increment i
  j = DFA[haystack.charAt(i)][j];
}
if (j == M) return i - M;
else return -1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;method-2-1d-restart-table-array&#34;&gt;Method 2: 1D Restart Table Array&lt;/h2&gt;

&lt;p&gt;restart[M]
restart[j - 1] gives which character in needle to match against index i in haystack when a mismatch happens at index j of needle.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;          A B A B A C
restart:  0 0 1 2 3 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compare suffix needle[j, M-1] with needle, longest common prefix&amp;rsquo;s length.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int state = 0;
for (int j = 1; j &amp;lt; M;) {
  if (needle.charAt(j) == needle.charAt(state)) {
    restart[j++] = ++state;
  } else if (state == 0) j++;
  else state = restart[state - 1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To compare, now has to back up, cannot operate on stream like standard input without buffering.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int i = 0, j = 0; i &amp;lt; N - M &amp;amp;&amp;amp; j &amp;lt; M;) {
  if (needle.charAt(j) == haystack.charAt(i)) {
    j++;
    i++;
  }
  else if (j == 0) i++;
  else j = restart[j - 1]; 
}
if (j == M) return i - j;
else return -1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Question: worst case operations 2N, practical 1.1 N. Why 2N?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sorting Algorithm Summary</title>
      <link>http://jessezhuang.github.io/article/algorithm-sorting-summary/</link>
      <pubDate>Mon, 18 Jul 2016 00:52:13 -0700</pubDate>
      
      <guid>http://jessezhuang.github.io/article/algorithm-sorting-summary/</guid>
      <description>&lt;p&gt;The following table summarizes common characteristics of popular sorting algorithms, not including string sort algorithms (I may add those later here or write another separate post).&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;algorithm&lt;/th&gt;
&lt;th&gt;In Place?&lt;/th&gt;
&lt;th&gt;Stable?&lt;/th&gt;
&lt;th&gt;parallel?&lt;/th&gt;
&lt;th&gt;worst&lt;/th&gt;
&lt;th&gt;average&lt;/th&gt;
&lt;th&gt;best&lt;/th&gt;
&lt;th&gt;remarks&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;selection&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;N exchanges&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;insertion&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/4&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;use for small N or partially ordered&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;tight code, sub quadratic&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;merge&lt;/td&gt;
&lt;td&gt;n&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;NlgN&lt;/td&gt;
&lt;td&gt;NlgN&lt;/td&gt;
&lt;td&gt;NlgN&lt;/td&gt;
&lt;td&gt;NlgN guarantee, stable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;quick&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;2NlnN&lt;/td&gt;
&lt;td&gt;NlgN&lt;/td&gt;
&lt;td&gt;probabilistic guarantee, fastest in practice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;heap&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;2NlgN&lt;/td&gt;
&lt;td&gt;2NlgN&lt;/td&gt;
&lt;td&gt;NlgN&lt;/td&gt;
&lt;td&gt;NlgN guarantee, in place&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;counting&lt;/td&gt;
&lt;td&gt;n&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;N+R&lt;/td&gt;
&lt;td&gt;N+R&lt;/td&gt;
&lt;td&gt;N+R&lt;/td&gt;
&lt;td&gt;integer keys, suitable where max-min (R) not &amp;gt;&amp;gt; N, often used as subroutine of radix sort. If sparse, can use hashmap to save space.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;N&lt;sup&gt;2&lt;/sup&gt;/2&lt;/td&gt;
&lt;td&gt;N+k&lt;/td&gt;
&lt;td&gt;N+k&lt;/td&gt;
&lt;td&gt;k denotes number of buckets, needs linked lists, dynamic arrays to hold items in buckets&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Cartesian&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;Nlogk&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;k denotes average of number of consecutive pairs, can be viewed as a version of selection and heap sort maintaining a priority queue&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are in place merge sort algorithms which are a little nontrivial to implement, one way is to do in place merge with bottom up approach. Merge sort on linked lists uses O(1) extra space.&lt;/li&gt;
&lt;li&gt;3-way quick sort can improve best case running time to O(N) in presence of duplicate keys.&lt;/li&gt;
&lt;li&gt;Counting sort with key indexed counting is stable, uses extra O(N) space for output array. If disregarding the count array, the input array can be used for returning although it is no longer stable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implementations in Core Java as of JDK 1.8, &lt;code&gt;DualPivotQuickSort&lt;/code&gt; (cut off threshhold of 47 to insertion sort) is used for primitives and a variant of &lt;code&gt;TimSort&lt;/code&gt; (a stable, adaptive, iterative merge sort adapted from Tim Peter&amp;rsquo;s list sort for Python, uses binary insertion sort) is used for objects.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>